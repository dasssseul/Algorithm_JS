# Basic Alogorithm

자주 나오는 기본 알고리즘 정리

## 연결 리스트 (Linked List)

### 연결 리스트란?

- 각 요소를 포인터로 연결하여 관리하는 선형 자료구조
- 각 요소는 노드라고 부르며 데이터 영역과 포인터 영역으로 구성된다

### 연결 리스트의 특징

- 메모리가 허용하는 한 요소를 제한없이 추가
- 탐색은 O(n)이 소요
- 요소를 추가하거나 제거할 때는 O(1)이 소요

### 배열과 연결 리스트의 차이점

- 배열의 요소 추가와 삭제는 선형 시간이 소요
  - 중간에 요소를 추가하기위해 뒷 요소들을 한 칸씩 밀어줘야하기 때문
- 연결 리스트의 요소 추가와 삭제는 상수 시간이 소요

### 연결 리스트의 요소 삭제 로직

- 삭제할 요소의 이전 요소가 가르키는 포인터를 삭제할 요소의 다음 요소를 가르키도록 연결한다
- 삭제할 요소를 완전히 삭제해준다

### 연결 리스트의 요소 추가 로직

- 추가할 요소의 포인터를 끼어 넣을 부분의 다음 요소를 가르키도록 만든다
- 끼어 넣을 부분 이전 요소의 포인터를 추가할 요소를 가르키도록 만든다

</br>

## 스택 (Stack)

### 스택이란?

- LIFO(Last In First Out) 개념을 가진 선형 자료 구조
- Array의 push, pop을 이용하여 쉽게 구현 가능
- Linked List의 헤드를 Top(바닥이 막힌 상자의 제일 위)으로 생각하면 구현 가능
  - 헤드를 push로 삽입해주고, pop으로 제거하는 방식

</br>

## 큐 (Queue)

### 큐란?

- FIFO(First In First Out) 개념을 가진 선형 자료 구조
- queue의 맨 앞을 Front, 맨 뒤를 Rear라고 부른다
- queue에 요소를 추가하는 것을 enqueue, 요소를 빼는 것을 dequeue라고 부른다
- Array를 이용하여 구현 가능하지만, Front와 Rear가 무한정으로 커지는 문제 발생
- Linked List를 이용하여 Head를 Front로, Tail을 Rear로 설정하면 Front와 Rear 인덱스가 무한정 커지는 문제 해결 가능

## 해시 테이블 (HashTable)

### 해시 테이블이란?

- 키와 값을 받아 해싱하여 나온 index에 값을 저장하는 선형 자료구조
- 삽입은 O(1)이며 키를 알고 있다면 삭제, 탐색도 O(1)로 수행한다

### 해시 함수란?

- 입력 받은 값을 특정 범위 내 숫자로 변경하는 함수

### 해시 충돌과 해결법

- 해시 충돌 : 해시 함수의 결과가 동일하여 겹치는 문제
- 해결법
  - 선형 탐사법 : 충돌이 발생하면 옆으로 한 칸 이동한다
    - 특정 영역에 데이터가 몰릴 수 있고, 이동한 버킷에서 또 충돌이 발생할 수도 있다
  - 제곱 탐사법 : 충돌이 발생하면 충돌이 발생한 횟수의 제곱만큼 옆으로 이동한다
  - 이중 해싱 : 충돌이 발생하면 다른 해시 함수를 이용한다(해시 함수1, 해시 함수2...)
  - 분리 연결법 : 버킷의 값을 연결 리스트로 사용하여 충돌이 발생하면 리스트에 값을 추가한다
    - 최악의 경우 하나의 버킷이 무한정 늘어날 수 있는 단점 존재

</br>

## 그래프 (Graph)

### 그래프란?

- 정점과 정점 사이를 연결하는 간선으로 이루어진 비선형 자료구조
- 정점(Node) 집합과 간선(Edge) 집합으로 표현할 수 있다

### 그래프의 특징

- 정점은 여러 개의 간선을 가질 수 있다
- 크게 방향 그래프와 무방향 그래프로 나눌 수 있다
- 간선은 가중치를 가질 수 있다
- 사이클이 발생할 수 있다

### 무방향 그래프란?

- 간선으로 이어진 정점끼리는 양방향으로 이동이 가능하다
- (A, B)와 (B, A)는 같은 간선으로 취급된다

### 방향 그래프란?

- 간선에 방향성이 존재하는 그래프
- 양방향으로 갈 수 있더라도 <A, B>와 <B, A>는 다른 간선으로 취급된다

### 연결 그래프란?

- 모든 정점이 서로 이동 가능한 상태인 그래프

### 비연결 그래프란?

- 특정 정점쌍 사이에 간선이 존재하지 않는 그래프

### 완전 그래프란?

- 모든 정점끼리 연결된 상태인 그래프

### 사이클

- 그래프의 정점과 간선의 부분 집합에서 순환이 되는 부분

### 그래프의 구현 방법

- 인접 행렬
  - 정점의 크기만큼 2차원 배열을 만들고, 연결이 안 된 상태로 초기화
- 인접 리스트
  - 정점의 수만큼 배열을 만들고, 연결할 정점을 배열에 추가

</br>

## 트리 (Tree)

### 트리란?

- 방향 그래프의 일종으로 정점을 가리키는 간선이 하나 밖에 없는 구조를 가지고 있다
- Root : 가장 상위에 존재하는 정점
- Node : 각 정점
- Leaf Node : 더이상 자식이 없는 노드
- Level : Root로 부터 몇번째 깊이인지를 표현
- Degree(차수) : 한 정점에서 뻗어나가는 간선의 수

### 트리의 특징

- 루트 정점을 제외한 모든 정점은 반드시 하나의 부모 정점을 가진다
- 정점이 N개인 트리는 반드시 N-1개의 간선을 가진다
- 루트에서 특정 정점으로 가능 경로는 유일하다

### 이진 트리

- 각 정점이 최대 2개의 자식을 가지는 트리

### 이진 트리의 특징

- 정점이 N개인 이진 트리는 최악의 경우 높이가 N이 될 수 있다(포화 이진 트리)
- 정점이 N개인 포화 또는 완전 이진 트리의 높이는 logN이다
- 높이가 h인 포화 이진 트리는 2^h -1개의 정점을 가진다
- 일반적인 이진 트리를 사용하는 경우보다 응용되는 경우가 많다
  - 이진 탐색 트리
  - 힙
  - AVL 트리
  - 레드 블랙 트리

### 트리의 구현 방법

- 인접 행렬
- 인접 리스트

### 이진 트리의 구현 방법

- 배열 혹은 요소에 링크가 2개 존재하는 연결 리스트로 구현

</br>

## 힙 (Heap)

### 우선순위 큐란?

- FIFO인 큐와 달리 우선 순위가 높은 요소가 먼저 나가는 큐

### 힙이란?

- 이진 트리의 형태를 가지며 우선순위가 높은 요소가 먼저 나가기 위해 요소가 삽입, 삭제될 때 바로 정렬되는 특징이 있다

### 힙의 특징

- 우선 순위가 높은 요소가 먼저 나가는 특징을 가진다
- 루트가 가장 큰 값이 되는 최대 힙(Max Heap)과 루트가 가장 작은 값이 되는 최소 힙(Min Heap)이 있다
- 자바스크립트에서는 직접 구현해서 사용해야한다

### 힙 요소 추가 알고리즘

- 요소가 추가될 때는 트리의 가장 마지막 정점에 위치한다
- 추가 후 부모 정점보다 우선 순위가 높다면 부모 정점과 순서를 바꾼다
- 위 과정을 반복하면 가장 우선 순위가 높은 정점이 루트가 된다
- 완전 이진 트리의 높이는 logN이기에 힙의 요소 추가 알고리즘은 O(logN) 시간 복잡도를 가진다

### 힙 요소 제거 알고리즘

- 요소 제거는 루트 정점만 가능하다
- 루트 정점이 제거된 후 가장 마지막 정점이 루트에 위치한다
- 루트 정점의 두 자식 정점 중 더 우선 순위가 높은 정점과 바꾼다
- 두 자식 정점이 우선 순위가 더 낮을 때까지 반복한다
- 완전 이진 트리의 높이는 logN이기에 힙의 요소 제거 알고리즘은 O(logN) 시간 복잡도를 가진다

</br>

## 트라이 (Trie)

### 트라이란?

- 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료 구조

### 트라이의 특징

- 검색어 자동 완성, 사전 찾기 등에 응용될 수 있다
- 문자열을 탐색할 때 단순하게 비교하는 것보다 효율적으로 찾을 수 있다
- L이 문자열의 길이일 때 탐색, 삽입은 O(L)만큼 걸린다
- 각 정점이 자식에 대한 링크를 전부 가지고 있기 때문에 저장 공간을 더 많이 사용한다

### 트라이 구조

- 루트는 비어있다
- 각 간선(링크)은 추가될 문자를 키로 가진다
- 각 정점은 이전 정점의 값 + 간선의 키를 값으로 가진다
- 해시 테이블과 연결 리스트를 이용하여 구현할 수 있다

</br>

## 정렬 (Sort)

### 정렬이란?

- 요소들을 일정한 순서대로 열거하는 알고리즘

### 정렬의 특징

- 정렬 기준은 사용자가 정할 수 있다
- 크게 비교식과 분산식 정렬로 나눌 수 있다
- 대부분의 언어가 빌트인으로 제공해준다
- 삽입, 선택, 버블, 머지, 힙, 퀵 정렬 등 다양한 정렬 방식이 존재한다

### 비교식 정렬

- 버블 정렬
  - 서로 인접한 두 요소를 검사하여 정렬하는 알고리즘
  - O(n^2) 시간 복잡도를 가진다
- 선택 정렬
  - 선택한 요소와 가장 우선 순위가 높은 요소를 교환하는 정렬 알고리즘
  - O(n^2) 시간 복잡도를 가진다
- 삽입 정렬
  - 선택한 요소를 삽입할 수 있는 위치를 찾아 삽입하는 방식의 정렬 알고리즘
  - O(n^2) 시간 복잡도를 가진다

### 분산식 정렬

- 분할 정복 알고리즘
  - 문제를 작은 2개의 문제로 분리하고 더 이상 분리가 불가능 할 때 처리한 후 합치는 전략
- 합병 정렬
  - 분할 정복 알고리즘을 이용한 최선과 최악이 같은 안정적인 정렬 알고리즘
  - O(nlogN) 시간 복잡도를 가진다
- 퀵 정렬
  - 분할 정복 알고리즘을 이용하여 매우 빠르지만 최악의 경우가 존재하는 불안정 정렬
  - O(nlogN) 시간 복잡도를 가진다

</br>

## 이진 탐색 (Binary Search)

### 이진 탐색이란?

- 정렬 되어 있는 요소들을 반씩 제외하며 찾는 알고리즘
- O(logN)만큼 시간 복잡도가 걸린다

### 이진 탐색의 특징

- 반드시 정렬이 되어있어야 사용할 수 있다
- 배열 혹은 이진 트리를 이용하여 구현할 수 있다
- O(logN) 시간 복잡도가 걸리는 만큼 상당히 빠르다

### 이진 탐색 트리

- 이진 탐색을 위한 이진 트리
- 왼쪽 서브 트리는 루트보다 작은 값이 모여있고, 오른쪽 서브 트리는 루트보다 큰 값이 모여있다

### 이진 탐색 트리의 문제점

- 최악의 경우 한쪽으로 편향된 트리가 될 수 있다
- 그런 경우 순차 탐색과 동일한 시간 복잡도를 가진다
- 이를 해결하기위해 AVL트리, 레드-블랙 트리 자료구조를 이용할 수 있다

</br>

## BFS와 DFS

### BFS(너비 우선 탐색)이란?

- 그래프 탐색 알고리즘으로 같은 깊이에 해당하는 정점부터 탐색하는 알고리즘

### BFS의 특징

- Queue를 이용하여 구현할 수 있다
- 시작 지점에서 가까운 정점부터 탐색한다
- V가 정점의 수, E가 간선의 수일 때 BFS의 시간 복잡도는 O(V+E)이다

### DFS(깊이 우선 탐색)이란?

- 그래프 탐색 알고리즘으로 최대한 깊은 정점부터 탐색하는 알고리즘

### DFS의 특징

- Stack을 이용하여 구현할 수 있다
- 시작 정점에서 깊은 것부터 찾는다
- V가 정점의 수, E가 간선의 수일 때 DFS의 시간 복잡도는 O(V+E)이다

</br>

## 그리디 (Greedy)

### 그리디란?

- 매 선택에서 지금 이 순간 가장 최적인 답을 선택하는 알고리즘
- 최적 해를 보장해주지 않는다

### 그리디 알고리즘의 특징

- 보통 최적해를 구하는 알고리즘보다 빠른 경우가 많다
- 크루스칼, 다익스트라 알고리즘에 사용된다
- 직관적인 문제 풀이에 적합하다
